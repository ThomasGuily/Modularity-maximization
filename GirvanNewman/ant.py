# -*- coding: utf-8 -*-
"""Graph.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o3aixcpjEW57dxkRBfZWAYPWZgl4VCWL
"""

import networkx as nx
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import random as rd

"""Définition des fonctions"""

def makeAdjancencyMatrix(head, succ):

    tmp = []
    for i in range(0, len(head) - 1):
        tmp.append(succ[head[i] - 1: head[i + 1] - 1])
    # print(tmp)
    # print(np.shape(tmp)[0])
    adjacency = np.zeros((np.shape(tmp)[0], np.shape(tmp)[0]))
    #print(adjacency)
    for i in range(0, np.shape(tmp)[0]):
        for j in range(0, np.shape(tmp[i])[0]):
            if tmp[i]:
                tmp1 = tmp[i][j] - 1
                adjacency[i][tmp1] = 1
    #print(adjacency)
    return(adjacency)
def readfile(chemin):
  f=open(chemin, 'r')
  fl=f.readlines()
  matrix = []
  #tmp = []
  for x in fl:
    x=list(map(int, x.split())) #séparer les instances quand on rencontre un espace
    matrix.append(x)
    # print(matrix)
  np.shape(matrix[0])
  if np.shape(matrix)[0]>=4 and matrix[0]!=0 and matrix[1]!=0:
    nbArrete=matrix[0]
    nbSommet=matrix[1]
    head = matrix[2]
    successor = matrix[3]
    return(nbArrete,nbSommet,head,successor,makeAdjancencyMatrix(head, successor))

def makeParition(sommet):
    indice=[]
    for i in range (len(sommet)):
        for j in range (len(sommet)):
            indice.append([sommet[i], sommet[j]])

    return indice
def modularity(diff, nbArete, regions):
    mod=0
    for i in regions:
        tmp=makeParition(i)
        for y in range(np.shape(tmp)[0]):
            print('')
            mod += (diff[tmp[y][0]][tmp[y][1]])
    mod = mod / (2 * nbArete)
    return (mod)

# def modularity(matrix, nbArete):
#     diff=[]
#     degree = []
#     prob=[]
#     #Calcul du degrès de chaque sommet dans variable degree
#     for i in range(np.shape(matrix)[0]):
#         degree.append(np.sum(matrix[i]))
#     tmp = []
#     #Construction de la matrice de probabilité
#     for i in range(np.shape(matrix)[0]):
#         for j in range(len(matrix[0])):
#             tmp.append((degree[i] * degree[j]) / (2 * nbArete))
#         prob.append(tmp)
#         tmp = []
#     # print(prob)
#     # print(matrix)
#     #calcul de la différences
#     for i in range(np.shape(matrix)[0]):
#         for j in range(np.shape(matrix)[1]):
#             tmp.append(matrix[i][j] - prob[i][j])
#         diff.append(tmp)
#         tmp = []
#     #Admettons on a deux groupes 123 et 456
#     P1=makeParition([0,1,2])
#     P2=makeParition([3,4,5])
#     print(P1, P2)
#     print(np.shape(P1), np.shape(P2))
#     mod=0;
#     print(P1[1][0], P1[1][1])
#     for i in range (np.shape(P1)[0]):
#         print('')
#         mod+=(diff[P1[i][0]][P1[i][1]])
#     for i in range (np.shape(P2)[0]):
#         print('')
#         mod+=(diff[P2[i][0]][P2[i][1]])
#     mod=mod/(2*nbArete)
#     print(mod)
#     return (mod)

def diffmatrix(matrix, nbArete):
    diff=[]
    prob=[]
    degree = []
    #Calcul du degrès de chaque sommet dans variable degree
    for i in range(np.shape(matrix)[0]):
        degree.append(np.sum(matrix[i]))
    tmp = []

    #Construction de la matrice de probabilité
    for i in range(np.shape(matrix)[0]):
        for j in range(len(matrix[0])):
            tmp.append((degree[i] * degree[j]) / (2 * nbArete))
        prob.append(tmp)
        tmp = []

    #calcul de la différences
    for i in range(np.shape(matrix)[0]):
        for j in range(np.shape(matrix)[1]):
            tmp.append(matrix[i][j] - prob[i][j])
        diff.append(tmp)
        tmp = []
    return(diff)

def rndCommAttrib(nbSommet, nbComm):
    # Génération de la taille des régions
    _sum = nbSommet
    n = nbComm
    if (_sum >= n):
        rnd_array = np.random.multinomial(_sum, np.ones(n) / n, size=1)[0]
        print(rnd_array)
    else:
        raise Exception('Error number of regions greater than number of heads')

    # Attribution aléatoire des éléments à des régions
    sommets = list(range(0, nbSommet))
    tmp = []
    communities = []
    for i in rnd_array:
        if(i!=0):
            for y in range(i):
                # print()
                rnd_index = rd.randrange(len(sommets))
                tmp.append(sommets[rnd_index])
                del sommets[rnd_index]
            communities.append(tmp)
            tmp = []
    # print(communities)
    return(communities)

def initialize(nbSolution, nbSommet, nbArete, diff):
    solutions={}
    
    # print(modularity(diff, nbArete, rndCommAttrib(nbSommet,6)))
    for i in range(nbSolution):
        comm = rndCommAttrib(nbSommet, 2)
        print(modularity(diff, nbArete, comm))
        solutions[modularity(diff, nbArete, comm)]=comm
    return(solutions)



def main():

    print("python main function")
    a = readfile ("./graph4.txt")
    print (a[4])
    print (a[1][0])
    f= open("./graph4form.txt","w+")
    for i in range (a[1][0]):
        for j in range (a[1][0]):
            if (a[4][i,j] == 1.0):
                go = ""+str(i)+","+str(j)+",1\n"
                f.write(go)
                
    
    f.close() 


    



if __name__ == '__main__':
    main()